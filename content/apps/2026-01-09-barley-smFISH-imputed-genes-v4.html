---
title: 'Barley Imputed spike smFISH'
author: Junli Zhang
date: '2026-01-09'
slug: barley-spike-smFISH-imputed
categories:
  - tools
tags:
  - smFISH
  - scRNA-seq
  - fullHtml
  - barley
---

<!-- v3: change color scales for color blind friendly-->
<!-- v3.1: change color scales to regular but add a option for color blind friendly-->
<!-- v4: 2026-01-09: clusters are from files, major changes -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wheat spike imputed Resolve smFISH</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
	<script src="https://biowasm.com/cdn/v3/aioli.js"></script>
	<script src="https://code.jquery.com/jquery-3.6.3.min.js"></script>
	<link
	rel="stylesheet"
	href="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.15.2/css/selectize.default.min.css"
	integrity="sha512-pTaEn+6gF1IeWv3W1+7X7eM60TFu/agjgoHmYhAfLEU8Phuf6JKiiE8YmsNC0aCgQv4192s4Vai8YZ6VNM6vyQ=="
	crossorigin="anonymous"
	referrerpolicy="no-referrer"
	/>
	<script
	src="https://cdnjs.cloudflare.com/ajax/libs/selectize.js/0.15.2/js/selectize.min.js"
	integrity="sha512-IOebNkvA/HZjMM7MxL0NYeLYEalloZ8ckak+NDtOViP7oiYzG5vn6WVXyrJDiJPhl4yRdmNAG49iuLmhkUdVsQ=="
	crossorigin="anonymous"
	referrerpolicy="no-referrer"
	></script>
    <style>
         body {
            font-family: Arial, sans-serif;
            margin: 20px;
            overflow: auto;
        }
        #container {
            display: flex;
            flex-direction: column;
            /* gap: 10px; */
            /* height: 90vh; */
        }
        #svg-wrapper {
            border: 1px solid #ccc;
            margin-top: 2px;
            overflow: hidden;
            flex-grow: 1;
            position: relative;
			/*min-height: 700px; /* Ensure it doesn't shrink */
        }
        #svg-container {
            width: 100%;
            /* height: 100%; */
			/* height: 110vw; */
			/* aspect-ratio: 12/11; */
			height: 800px; /* Fixed height for the SVG */
			min-height: 700px; /* Ensure it doesn't shrink */
        }
        #controls {
            display: flex;
            gap: 10px;
            /* margin-bottom: 10px; */
            align-items: center;
            flex-wrap: wrap;
        }
        .gene-control {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f9f9f9;
        }
        select {
            min-width: 200px;
            padding: 5px;
        }
        #web-legend {
            /* display: flex; */
            gap: 10px;
            margin-top: 10px;
			margin-right: 10px;
        }
        .legend-item {
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f9f9f9;
			Display: block;
			gap:10px;
        }
        .color-legend {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border: 1px solid #333;
        }
        button {
            padding: 5px 10px;
            cursor: pointer;
        }
        .loading {
            display: inline-block;
            margin-left: 10px;
            color: #666;
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .zoom-btn {
            width: 30px;
            height: 30px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 16px;
            cursor: pointer;
        }
        .zoom-btn:hover {
            background: #f0f0f0;
        }
        .no-selection {
            color: #999;
            font-style: italic;
        }
        #export-controls {
            margin-top: 10px;
        }
        .svg-legend {
            font-family: Arial, sans-serif;
            font-size: 12px;
        }
		.left {
        float: left;
        width: 20%;
    }
		.right {
			float: right;
			width: 75%;
			margin-left:1%;
			margin-right:2%;
		}
		div.tooltip-donut {
			position: absolute;
			text-align: center;
			padding: .5rem;
			background: #FFFFFF;
			color: #313639;
			border: 1px solid #313639;
			border-radius: 8px;
			pointer-events: none;
			font-size: 0.8rem;
		}
		.selectize-input {
			width: 200px; /* Or any other desired width */
		}
		.button-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
			margin-top:10px;
        }
		/* button {
            padding: 8px 16px;
            border: none;
            cursor: pointer;
            width: 150px;
        } */
        #toggleSelection {
            background-color: #4CAF50;
            color: white;
        }
        #toggleSelection.active {
            background-color: #f44336;
        }
        #clear {
            background-color: #2196F3;
            color: white;
        }
        #logSelection {
            background-color: #ff9800;
            color: white;
        }
        #zoomIn, #zoomOut, #resetZoom {
            background-color: #9e9e9e;
            color: white;
        }
        button:hover {
            opacity: 0.8;
        }
        #selectedIds {
            /* margin-top: 10px; */
            padding: 5px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        .instructions {
            font-size: 0.9em;
            color: #666;
            /* margin-bottom: 10px; */
        }
		textarea {
            width: 90%;
            height: 200px;
            margin-bottom: 20px;
            padding: 10px;
            box-sizing: border-box;
        }
		#legend {
            margin-top: 20px;
        }
        .cluster-legend-item {
            display: flex;
            align-items: center;
            padding: 5px;
            border-radius: 4px;
            background: #f0f0f0;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #333;
            flex-shrink: 0;
        }
        .legend-label {
            display: flex;
            align-items: center;
            flex-grow: 1;
            cursor: pointer;
        }
		.scrollable-div {
			/*max-width: 500px; /* Set your desired max width */
			max-height: 600px; /* Set your desired max height */
			overflow: auto; /* Add scrollbars when content overflows */
			/*border: 1px solid #ccc; /* Add a border for visibility */
			/*padding: 10px; /* Add some padding */
		}
    </style>
</head>
<body>
    <!-- <h1>JD99 wheat spike simFISH spatial transcriptomics</h1> -->
	<div class="left">
		<h2>W3.5 Cluster Map</h2>
		<div id="legend" class="scrollable-div"></div>
		<div id="web-legend">
			<input type="checkbox" id="colorblind" name="colorblind" value="yes">
			<label for="colorblind"> Colorblind friendly</label><br>
            <div class="legend-item">
				<div id="fill-legend">
                	<strong>Gene 1:</strong> <span class="no-selection">None selected</span>
				</div>
				<div class="slider-container">
					<output id="value-display1">Display threshold:</output><br>
					<input type="range" id="value-filter1" min="1" max="100" value="1" style="width:90%;">
				</div>
            </div>
            <div class="legend-item">
				<div id="stroke-legend">
                	<strong>Gene 2:</strong> <span class="no-selection">None selected</span>
				</div>
				<div class="slider-container">
					<output id="value-display2">Display threshold:</output><br>
					<input type="range" id="value-filter2" min="1" max="100" value="1" style="width:90%;">
				</div>
            </div>
			<div id="gene-controls">
				<button id="export-svg">Download SVG image</button><br><br>
				<button id="export-png">Download png image at quality</button>
				<!-- <label for="png-quality">png image quality</label> -->
				<input type="number" id="png-quality" name="png-quality" value="5" size="1" max = "10" min="1"><br><br>
				<button id="findcell" onclick="highlightCell()">Find a cell</button>
  				<input type="text" id="highlight-cell" name="highlight-cell">
			</div>
			<p>Paste your gene list to check with the "Last gene" and "Next gene" buttons.</p>
			<textarea id="textInput" placeholder="Enter multiple genes here, each line is one gene ..."></textarea>
        </div>
	</div>
    <div id="container" class="right">
		<h2>Expression Heatmap</h2>
        <div id="controls">
            <div class="gene-control">
                <label for="fill-gene-select">Gene 1 (cell color):</label>
                <select id="fill-gene-select">
                    <option value="">     -- None --     </option>
                </select>
                <div id="fill-loading" class="loading"></div>
            </div>
            <div class="gene-control">
                <label for="stroke-gene-select">Gene 2 (cell border color):</label>
                <select id="stroke-gene-select">
                    <option value="">     -- None --     </option>
                </select>
                <div id="stroke-loading" class="loading"></div>
            </div>
			<div class="controls">
				<button id="lastBtn" disabled title="last gene in the text box on the bottom-left corner">Last gene</button>
				<button id="nextBtn" disabled title="next gene in the text box on the bottom-left corner">Next gene</button>
			</div>
			<div class="counter">
				<span id="currentLine">0</span> / <span id="totalLines">0</span>
			</div>
        </div>
        <!-- <div class="button-group">
            <button id="toggleSelection" title="Toggle selection mode to select cells with freehand drawing. Disable to zoom or drag.">Enable Cell Selection</button>
            <button id="clear">Clear Cell Selection</button>
			<button id="downloadExpression">download transcripts of selected cells</button>
        </div> -->
        <!-- <div class="instructions">
            <p id="modeInstructions">Toggle selection mode to select cells with freehand drawing. When not in selection mode: Mouse wheel to zoom, drag to pan</p>
        </div> -->
        <div id="selectedIds" style="display: none;">Selected IDs will appear here</div>
        <div id="svg-wrapper">
            <div id="svg-container"></div>
            <div class="zoom-controls">
                <button class="zoom-btn" id="zoom-in" title="zoom in">+</button>
                <button class="zoom-btn" id="zoom-out" title="zoom out">-</button>
                <button class="zoom-btn" id="reset-zoom" title="reset">↻</button>
                <button class="zoom-btn" id="download-svg" title="download">↓</button>
            </div>
        </div>

		<div id="gene-controls">
			<h3>Help</h3>
			<p>To make it easier to view, I downloaded barley spatial and scRNA-seq data from <a href='https://www.plabipd.de/projects/hannah_demo/Barvista.html' target='_blank' class='url'>BARVISTA</a>. Here are the <strong>imputed gene expression</strong> for cells in single-molecule fluorescence in situ hybridization (smFISH) for barley apex at 2 stages (late double ridge (W0.5, vegetative shoot apical meristem (vSAM)) and floret primordia (W3.5) stages; W3.5 has two vertical images and a transverse section) using 100 genes for similarity analysis with the scRNA-seq data. Please check the reference below for details of the smFISH experiment and gene imputation process. You can find the best hit of wheat genes on Arabidopsis, rice, and barley here: <a href='https://junli.netlify.app/apps/wheat-homeolog/' target='_blank' class='url'>https://junli.netlify.app/apps/wheat-homeolog/</a></p>
			<p>Below is just a quick guide:</p>
			<ol>
				<li>On the left panel (W3.5 Cluster Map), you can view all or a few clusters of the smFISH genes for W3.5 vertical images.</li>
				<li>On the right panel (Expression Heatmap), you can check single gene or a pair of gene expression in each cell.</li>
				<li>"Gene 1" has heatmap for the cell fill color; "Gene 2" has heatmap for the cell border color. Values are counts per million per cell</li>
				<li>Select "Gene 1" or "Gene 2" will clear the cluster colors; and <strong>"Gene 1" compete the color fill colors with clusters</strong>.</li>
				<li>Gene 2 and the clusters can be shown at the same time, but make sure to select "Gene 2" first, then select the clusters.</li>
				<li>The imputed gene expression has background noises and you can filter the minimum counts to get cleaner heatmap. The default threshold is 10% of maximum.</li>
				<li>You can use the mouse wheel to zoom in or out; drag it to move.</li>
				<li>You can also select cells in a region and get all its imputed transcripts by clicking "Enable Cell Selection" button.</li>
				<li>You can download a SVG (Scalable Vector Graphics) format image or a high-quality PNG image.</li>
				<li>You can now click "Enable Cell Selection" to select a group of cells and export all the imputed transcripts of these cells.</li>
				<li>You can now check a list of genes quickly by pasating them in to the textbox on the bottom left corner; then go to top right corners and use the "Last Gene" and "Next Gene" button to check.</li>
				<li>You can <a href="https://wheatsinglecell.s3.us-east-2.amazonaws.com/data/barley_smFISH_genes.csv" download>download barley gene IDs (Morex V3) of the 100 smFISH genes</a>.</li>
			</ol>
			<h3>Reference</h3>
			<p>Demesa-Arevalo, E., Dӧrpholz, H., Vardanega, I. et al. Imputation integrates single-cell and spatial gene expression data to resolve transcriptional networks in barley shoot meristem development. Nat. Plants (2026). <a href="https://doi.org/10.1038/s41477-025-02176-6" target="_blank">https://doi.org/10.1038/s41477-025-02176-6</a></p>
			
		</div>
    </div>


<script id="geneHeatMap" type="module">
	// Global variables
	let expressionData = null;
	let fillGeneData = {};
	let strokeGeneData = {};
	let cellIds = [];
	let geneList = [];
	let fillColorChoice = d3.interpolateYlOrRd;
	let strokeColorChoice = t => d3.interpolateCool(1 - t);
	let fillColorScale = d3.scaleSequential(fillColorChoice);
	let strokeColorScale = d3.scaleSequential(strokeColorChoice); //(t => d3.interpolateCool(1 - t)); reverse the scale
	// colorblind checkbox element
	// https://sjmgarnier.github.io/viridis/
	// const mycolor = d3.scaleSequential()
	// 	.range(["#e4ff7a", "#ffe81a", "#ffbd00", "#ffa000", "#fc7f00"]) // Define your color stops
	// 	.domain([0, 0.25, 0.50, 0.75, 1]); // https://github.com/wistia/heatmap-palette
	const colorblind = document.getElementById("colorblind");
	colorblind.addEventListener('change', function() {
		if (this.checked) {
			fillColorChoice = t => d3.interpolatePlasma(1 - t); //interpolatePuOr;
			strokeColorChoice = t => d3.interpolateViridis(1 - t); // interpolateTurbo; //interpolateRdYlBu;
		} else {
			fillColorChoice = d3.interpolateYlOrRd;
			strokeColorChoice = t => d3.interpolateCool(1 - t);
		}
		fillColorScale = d3.scaleSequential(fillColorChoice);
		strokeColorScale = d3.scaleSequential(strokeColorChoice);
		const fillgene = d3.select('#fill-gene-select').node().value;
		const strokegene = d3.select('#stroke-gene-select').node().value;
		(async () => {
			if (fillgene) {
				await updateColorScale("fill", fillgene);
				updateLegend("fill", fillgene);
			}
			if (strokegene) {
				await updateColorScale("stroke", strokegene);
				updateLegend("stroke", strokegene);
			}
			updateAllPolygons();
		})();
	});

	// function to get clusters for all cells: {cell1:0, cell2:1, cell3:1}
	async function loadClusters(filePath) { // csv file with 2 columns with header: cell_id,group
		let cellCluster = {};
		await d3.csv(filePath, function(d) {cellCluster[d.cell_id] = d.group})
		return(cellCluster);
	}
	// function to get clusters for all cells: {cell1:0, cell2:1, cell3:1}
	async function loadClusterNames(filePath) { // csv file with 2 columns with header: cell_id,group
		let cellCluster = {};
		await d3.csv(filePath, function(d) {cellCluster[d.cluster] = d.name})
		return(cellCluster);
	}

	let zoom = d3.zoom();
	let g = null;
	let svgElement = null;
	let svgNode = null;
	let div = d3.select("body").append("div")
     .attr("class", "tooltip-donut")
     .style("opacity", 0); // to show cell information when mouse over
	const CLI = await new Aioli(["bcftools/1.10"]);
	// const baseURL = document.location.protocol + '//' + document.location.host;
	const baseURL = "https://wheatsinglecell.s3.us-east-2.amazonaws.com"
	const dataURL = baseURL + "/data/barley_imputed.txt.gz";
	const indexURL = dataURL + ".tbi"; // dataURL has columns: gene, cell, value;  good for retrieving gene expression across all cells
	// const dataURL2 = baseURL + "/data/merged_w2.5_w3.5_imputed_CPM_cosine_weighted_5neighbors_cell-gene-value.txt.gz";
	// const indexURL2 = dataURL2 + ".tbi"; // dataURL2 has columns: cell, gene, value; good for retrieving all gene expressions for selected cells
	console.log(dataURL);

	// Mount data. This mounts the URLs lazily
	// on the virtual file system. In other words, no data is downloaded yet.
	await CLI.mount([
		{ name: "test.txt.gz", url: dataURL },
		{ name: "test.txt.gz.tbi", url: indexURL },
		// { name: "test2.txt.gz", url: dataURL2 },
		// { name: "test2.txt.gz.tbi", url: indexURL2 },
	]);
	let tmp = CLI.exec("bcftools tabix test.txt.gz 1");
	// cell cluster
	const clusters = await loadClusters(baseURL + "/data/barley_D1-5-clusters.csv"); // {cell1:0, cell2:1, cell3:1}
	const clusterNames = await loadClusterNames(baseURL + "/data/barley_D1-5-cluster-names.csv"); // {cell1:0, cell2:1, cell3:1}

	// slider to filer values to display
	const slider1 = document.getElementById('value-filter1');
	const valueDisplay1 = document.getElementById('value-display1');
	const slider2 = document.getElementById('value-filter2');
	const valueDisplay2 = document.getElementById('value-display2');
	// Update display when slider moves
	slider1.addEventListener('input', function() {
		const threshold = this.value;
		valueDisplay1.textContent = `Display threshold: ${threshold}`;
		updateAllPolygons();
	});
	slider2.addEventListener('input', function() {
		const threshold = this.value;
		valueDisplay2.textContent = `Display threshold: ${threshold}`;
		updateAllPolygons();
	});

	// Load SVG file
	function loadSVG(svgUrl) {
		showLoading("fill", "Loading SVG...");
		d3.xml(svgUrl).then(function(data) {
			hideLoading("fill");
			svgNode = data.documentElement;
			const container = document.getElementById('svg-container');
			container.innerHTML = '';
			
			// Create a group element to hold the SVG and enable transforms
			svgElement = d3.select(container)
				.append('svg')
				.attr('width', '100%')
				.attr('height', '100%')
				.attr('preserveAspectRatio', 'xMidYMid meet');
			
			g = svgElement.append('g');
			g.node().appendChild(svgNode);
			svg = svgElement;
			
			// Initialize zoom behavior
			zoom.scaleExtent([0.01, 20]);
			zoom.on('zoom', (event) => {
				g.attr('transform', event.transform);
			});
			svg.call(zoom);
			
			// Fit the SVG to view initially
			resetZoom();

			// mouse over to show cell id and cluster number
			showInfo();
			
			// Initialize all polygons with default style
			updateAllPolygons();
		}).catch(error => {
			hideLoading("fill");
			console.error("Error loading SVG:", error);
			alert("Error loading SVG file. See console for details.");
		});
	}

	// highlight a cell with its name
	function highlightCell(){
		let cellID = document.getElementById("highlight-cell").value;
		if (cellID == "") alert("Input a cell ID!");
		else 
		{
			try {
				svgElement.select('#' + cellID).attr('fill', "red");
			} catch (error) {
				alert("Cell ID not found!");
			}
		}
	}

	// mouse over
	function showInfo(){
		// add mouse over
		svgElement.selectAll('polygon')
		.on('mouseover', function (d) {
			d3.select(this).transition()
				.duration('50')
				.attr('opacity', '.85');
			div.transition()
				.duration(50)
				.style("opacity", 1);
			// let num = (Math.round((d.value / d.data.all) * 100)).toString() + '%';
			// let info = this.id; // + "<br>" + this.getAttribute("class").replace("circle cluster-", "Cluster ");
			let info = this.id + "<br>Cluster " + clusters[this.id];
			if(fillGeneData && fillGeneData[this.id]) {
				let value = fillGeneData[this.id]; // gene 1 expression
				info += "<br>Gene 1 count: " + value.toFixed(0);
			}
			if(strokeGeneData && strokeGeneData[this.id]) {
				let value = strokeGeneData[this.id]; // gene 2 expression
				info += "<br>Gene 2 count: " + value.toFixed(0);
			}
			div.html(info)
				.style("left", (event.pageX + 10) + "px")
				.style("top", (event.pageY - 15) + "px");
		})
		.on('mouseout', function (d) {
			d3.select(this).transition()
				.duration('50')
				.attr('opacity', '1');
			div.transition()
				.duration('50')
				.style("opacity", 0);
		});
	}

	// Reset zoom to fit SVG
	function resetZoom() {
		const container = document.getElementById('svg-container');
		const svgEl = container.querySelector('svg');
		
		if (!svgEl || !g) return;
		
		const svgRect = svgEl.getBoundingClientRect();
		const contentRect = g.node().getBBox();
		
		// Calculate scale to fit
		const scale = Math.min(
			svgRect.width / contentRect.width,
			svgRect.height / contentRect.height,
			1 // Don't scale up beyond 100%
		);
		
		// Calculate center position
		const x = svgRect.width / 2 - (contentRect.x + contentRect.width / 2) * scale;
		const y = svgRect.height / 2 - (contentRect.y + contentRect.height / 2) * scale;
		
		// Apply transform
		g.attr('transform', `translate(${x},${y}) scale(${scale})`);
		
		// Update zoom state
		zoom.transform(
			d3.select('#svg-container svg'),
			d3.zoomIdentity.translate(x, y).scale(scale)
		);
	}

	// load cell names, a file with only one column, no header
	async function loadCellNames(filePath) {// load gene names and cell IDs
		showLoading("fill", "Loading cell names...");
		try {
			cellIds = await d3.csv(filePath, function(d) {return d.cellID;})
		} catch (error) {
			console.error("Error loading cell name CSV:", error);
			hideLoading();
			alert("Error processing cell name file. See console for details.");
		}
	}
	async function loadGeneNames(filePath) {// load gene names and cell IDs
		showLoading("fill", "Loading gene names...");
		try {
			// geneList = await d3.csv(filePath, function(d) {return "TrturKRN" + d.geneID;});
			geneList = await d3.csv(filePath, function(d) {return d.geneID;});
			// Update gene dropdown
			await updateGeneDropdowns();
			// init selectize after reading gene list
			$(function () {
				$("#fill-gene-select").selectize({
					onChange: async function() {
						const gene = this.getValue(); //this.value;
						if (gene) {
							await updateColorScale("fill", gene);
							updateLegend("fill", gene);
						} else {
							clearLegend("fill");
						}
						updateAllPolygons();
					},
				});
				$("#stroke-gene-select").selectize({
					onChange: async function() {
						const gene = this.getValue();
						if (gene) {
							await updateColorScale("stroke", gene);
							updateLegend("stroke", gene);
						} else {
							clearLegend("stroke");
						}
						updateAllPolygons();
					},
				});
			});
			// Load SVG after CSV is processed
			loadSVG(baseURL + '/images/barley-D1-5-D2-1-A1-4.svg'); // Change this to your SVG file path
		} catch (error) {
			console.error("Error loading gene names:", error);
			hideLoading();
			alert("Error processing gene name file. See console for details.");
		}
	}

	// Process expression data from CSV
	function processExpressionData(csvData) {
		// First row contains cell IDs (assuming first column is gene names)
		cellIds = csvData.columns.slice(1);
		
		// Extract gene names and expression values
		geneList = csvData.map(row => row[csvData.columns[0]]);
		
		// Convert to a more accessible structure: {gene: {cell1: value, cell2: value}}
		expressionData = {};
		csvData.forEach(row => {
			const gene = row[csvData.columns[0]];
			expressionData[gene] = {};
			cellIds.forEach(cellId => {
				expressionData[gene][cellId] = +row[cellId];
			});
		});
	}

	// Update all polygons based on current gene selections
	function updateAllPolygons() {
		if (!svgElement || svgElement.empty()) return;
		
		const fillGene = document.getElementById('fill-gene-select').value;
		const strokeGene = document.getElementById('stroke-gene-select').value;
		
		svgElement.selectAll('polygon').each(function() {
			const polygon = d3.select(this);
			const cellId = polygon.attr('id');
			
			// Default styles
			let fill = 'lightgray';
			let stroke = '';
			let strokeWidth = 0;
			
			// Apply fill color if gene is selected
			if (fillGene && fillGene !== "" && fillGeneData && cellId && fillGeneData[cellId] !== undefined) {
				const value = fillGeneData[cellId];
				// if (value > 0) fill = fillColorScale(value);
				if (value > slider1.value) fill = fillColorScale(value);
			}
			
			// Apply stroke color if gene is selected
			if (strokeGene && strokeGene !== "" && strokeGeneData && cellId && strokeGeneData[cellId] !== undefined) {
				const value = strokeGeneData[cellId];
				// if (value > 0){
				if (value > slider2.value){
					stroke = strokeColorScale(value);
					strokeWidth = 20; // Make stroke more visible when used for expression
				}
			}
			
			polygon.attr('fill', fill)
				.attr('stroke', stroke)
				.attr('stroke-width', strokeWidth);
		});
		
		// Update SVG legends
		// updateSVGLegends();
	}

	// Update gene dropdowns
	async function updateGeneDropdowns() {
		const fillSelect = d3.select('#fill-gene-select');
		const strokeSelect = d3.select('#stroke-gene-select');
		
		// Clear existing options except first (None)
		fillSelect.selectAll('option:not(:first-child)').remove();
		strokeSelect.selectAll('option:not(:first-child)').remove();
		
		// Add new options
		fillSelect.selectAll('option.gene')
			.data(geneList)
			.enter()
			.append('option')
			.attr('class', 'gene')
			.text(d => d)
			.attr('value', d => d);
		
		strokeSelect.selectAll('option.gene')
			.data(geneList)
			.enter()
			.append('option')
			.attr('class', 'gene')
			.text(d => d)
			.attr('value', d => d);
	}

	// get the counts data for a specific gene across all cells
	async function getGeneData(geneIndex) {
		// Retrieve SAM header on the first file provided
		let cmd = "bcftools tabix test.txt.gz " + geneIndex;
		console.log(cmd);
		const output = await CLI.exec(cmd);
		// console.log(output);
		let geneData = {};
		await d3.tsvParse("geneIndex\tcellIndex\tdata\n" + output, function(d){
			let cellId = cellIds[d.cellIndex - 1];
			geneData[cellId] = +d.data;
		});
		// console.log(geneData);
		return(geneData);
	}

	// Update color scale for a specific gene and type (fill/stroke)
	async function updateColorScale(type, gene) {
		if (!gene) return;
		const geneIndex = geneList.indexOf(gene) + 1;
		let geneData = await getGeneData(geneIndex); // global variable
		const values = Object.values(geneData).filter(v => !isNaN(v));
		const minVal = d3.min(values);
		const maxVal = d3.max(values);
		
		if (type === "fill") {
			fillGeneData = geneData;
			fillColorScale.domain([minVal, maxVal]);
			slider1.min = minVal;
			slider1.max = maxVal;
			slider1.value = (maxVal * 0.1).toFixed(0);
			valueDisplay1.textContent = `Display threshold: ${slider1.value}`;
		} else {
			strokeGeneData = geneData;
			strokeColorScale.domain([minVal, maxVal]);
			slider2.min = minVal;
			slider2.max = maxVal;
			slider2.value = (maxVal * 0.1).toFixed(0);
			valueDisplay2.textContent = `Display threshold: ${slider2.value}`;
		}
	}

	// Update web legend for a specific gene and type
	function updateLegend(type, gene) {
		// if (!expressionData || !gene) return;
		if (!gene) return;		
		const geneData = type === "fill" ? fillGeneData : strokeGeneData;
		const values = Object.values(geneData).filter(v => !isNaN(v));
		if (values.length == 0) {
			console.log("No values for " + gene + "\n");
			return;
		} 
		const minVal = d3.min(values);
		const maxVal = d3.max(values);
		const colorScale = type === "fill" ? fillColorScale : strokeColorScale;
		const interpolator = type === "fill" ? fillColorChoice : strokeColorChoice; //(t => d3.interpolateCool(1 - t));
		
		const legend = d3.select(`#${type}-legend`);
		legend.html('');
		legend.append('div').html(
                `<strong>${gene}</strong> (cell ${type === "fill" ? "fill" : "border"} color)`
            );
		
		const legendWidth = Math.min(200, document.getElementById('web-legend').offsetWidth * 0.9);
		const legendHeight = 20;
		const legendSvg = legend.append('svg')
			.attr('width', legendWidth)
			.attr('height', legendHeight + 20);
		
		// Create gradient
		const defs = legendSvg.append('defs');
		const gradient = defs.append('linearGradient')
			.attr('id', `${type}-gradient`)
			.attr('x1', '0%')
			.attr('y1', '0%')
			.attr('x2', '100%')
			.attr('y2', '0%');
		
		// Add color stops
		const stops = [0, 0.2, 0.4, 0.6, 0.8, 1];
		stops.forEach(stop => {
			gradient.append('stop')
				.attr('offset', `${stop * 100}%`)
				.attr('stop-color', interpolator(stop));
		});
		
		// Append gradient to rectangle
		legendSvg.append('rect')
			.attr('width', legendWidth)
			.attr('height', legendHeight)
			.style('fill', `url(#${type}-gradient)`);
		
		// Add scale labels
		legendSvg.append('text')
			.attr('x', 0)
			.attr('y', legendHeight + 15)
			.text(minVal.toFixed(0));
		
		legendSvg.append('text')
			.attr('x', legendWidth)
			.attr('y', legendHeight + 15)
			.attr('text-anchor', 'end')
			.text(maxVal.toFixed(0));
	}

	// Update SVG legends (added to the exported image)
	function updateSVGLegends() {
		if (!svgElement || svgElement.empty()) return;
		
		// Remove existing legends if they exist
		svgElement.selectAll('.svg-legend-group').remove();
		
		const fillGene = document.getElementById('fill-gene-select').value;
		const strokeGene = document.getElementById('stroke-gene-select').value;
		
		const origsvg = svgElement.selectAll('svg');
		origsvg.append('style').html(`text {font:20pt sans-serif;} tspan {font: 15pt sans-serif;}`);
		const legendGroup = origsvg.append('g')
			.attr('class', 'svg-legend-group')
			.attr('transform', `translate(160, 25)`);
		// Add fill legend if gene is selected
		if (fillGene && fillGene !== "") {
			addSVGLegend(legendGroup, "fill", fillGene, 0, 0);
		}
		
		// Add stroke legend if gene is selected
		if (strokeGene && strokeGene !== "") {
			addSVGLegend(legendGroup, "stroke", strokeGene, 450, 0);
		}
	}

	// Add a single legend to the SVG
	function addSVGLegend(container, type, gene, xOffset, yOffset) {
		// gene = gene.replace(/TrturKRN/g, ""); // TrturKRN2B01G037340
		const geneData = type === "fill" ? fillGeneData : strokeGeneData;
		// const geneData = expressionData[gene];
		const values = Object.values(geneData).filter(v => !isNaN(v));
		const minVal = d3.min(values);
		const maxVal = d3.max(values);
		const colorScale = type === "fill" ? fillColorScale : strokeColorScale;
		const interpolator = type === "fill" ? fillColorChoice : strokeColorChoice; //(t => d3.interpolateCool(1 - t));
		// const interpolator = type === "fill" ? fillColorChoice : d3.interpolateBuPu;
		
		const legendGroup = container.append('g')
			.attr('class', `svg-legend ${type}-legend`)
			.attr('transform', `translate(${xOffset}, ${yOffset})`);
		
		// Add title
		legendGroup.append('text')
			.attr('x', 0)
			.attr('y', 0)
			.attr('class', 'svg-legend-title')
			// .text(`${type === "fill" ? "Fill" : "Stroke"}: ${gene}`);
			.html(`<tspan>HORVU.MOREX.r3.</tspan>${gene}`);
		
		// Add color bar
		const legendWidth = 340;
		const legendHeight = 30;
		const margin = legendHeight * 1.2;
		
		// Create gradient
		const defs = container.append('defs');
		const gradientId = `svg-${type}-gradient`;
		const gradient = defs.append('linearGradient')
			.attr('id', gradientId)
			.attr('x1', '0%')
			.attr('y1', '0%')
			.attr('x2', '100%')
			.attr('y2', '0%');
		
		// Add color stops
		const stops = [0, 0.2, 0.4, 0.6, 0.8, 1];
		stops.forEach(stop => {
			gradient.append('stop')
				.attr('offset', `${stop * 100}%`)
				.attr('stop-color', interpolator(stop));
		});
		
		// Append gradient to rectangle
		legendGroup.append('rect')
			.attr('x', 0)
			.attr('y', 10)
			.attr('width', legendWidth)
			.attr('height', legendHeight)
			.style('fill', `url(#${gradientId})`)
			.attr('stroke', '#000')
			.attr('stroke-width', 0.5);
		
		// Add min/max labels
		legendGroup.append('text')
			.attr('x', 0)
			.attr('y', legendHeight + margin)
			.attr('class', 'svg-legend-label')
			.text(minVal.toFixed(0));
		
		legendGroup.append('text')
			.attr('x', legendWidth)
			.attr('y', legendHeight + margin)
			.attr('class', 'svg-legend-label')
			.attr('text-anchor', 'end')
			.text(maxVal.toFixed(0));
	}

	// Clear web legend for a specific type
	function clearLegend(type) {
		const legend = d3.select(`#${type}-legend`);
		legend.html('');
		
		// legend.append('strong').text(`${type === "fill" ? "Fill" : "Stroke"} Gene: `);
		legend.append('strong').text(`${type === "fill" ? "Gene 1" : "Gene 2"} `);
		legend.append('span').attr('class', 'no-selection').text('None selected');
	}

	// Export SVG with legends
	async function exportSVG() {
		if (!svgElement || svgElement.empty()) return;
		resetZoom(); // reset to save the whole picture
		updateSVGLegends(); // add legend to the svg file
		
		// Clone the SVG element to avoid modifying the original
		// const clone = svgElement.node().cloneNode(true);
		const origsvg = svgElement.selectAll('svg');
		const clone = origsvg.node().cloneNode(true);
		
		// Create a new SVG with the same dimensions
		const serializer = new XMLSerializer();
		let svgString = serializer.serializeToString(clone);
		
		// Add namespace if not present
		if (!svgString.match(/^<svg[^>]+xmlns="http:\/\/www\.w3\.org\/2000\/svg"/)) {
			svgString = svgString.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
		}

		// Add XML declaration
		svgString = '<?xml version="1.0" standalone="no"?>\n' + svgString;
		
		// Create a blob and download
		const blob = new Blob([svgString], {type: 'image/svg+xml'});
		const url = URL.createObjectURL(blob);
		const link = document.createElement('a');
		link.href = url;
		link.download = 'heatmap_visualization.svg';
		document.body.appendChild(link);
		link.click();
		document.body.removeChild(link);
		svgElement.selectAll('.svg-legend-group').remove(); // remove the legend after downloading
		svgElement.select("style").remove();
	}

	function svgToPng(svgString, width, height) {
		return new Promise((resolve, reject) => {
			const img = new Image();
			img.onload = () => {
			const canvas = document.createElement("canvas");
			canvas.width = width;
			canvas.height = height;
			const ctx = canvas.getContext("2d");
			ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
			const pngDataUrl = canvas.toDataURL("image/png");
			resolve(pngDataUrl);
			};
			img.onerror = reject;
			img.src = "data:image/svg+xml;base64," + btoa(svgString);
		});
	}

	// Export SVG with legends
	async function exportPNG() {
		if (!svgElement || svgElement.empty()) return;
		resetZoom(); // reset to save the whole picture
		updateSVGLegends(); // add legend to the svg file
		
		// Clone the SVG element to avoid modifying the original
		// const clone = svgElement.node().cloneNode(true);
		const origsvg = svgElement.selectAll('svg');
		const clone = origsvg.node().cloneNode(true);
		const width = parseInt(clone.getAttribute('width')) || 1200;
		const height = parseInt(clone.getAttribute('height')) || 1600;
		// Ensure viewBox is set
		if (!clone.getAttribute('viewBox')) {
			clone.setAttribute('viewBox', `0 0 ${width} ${height}`);
		}
		
		// Set output dimensions to match canvas
		let svgScale = document.getElementById('png-quality').value;
		clone.setAttribute('width', width * svgScale);
		clone.setAttribute('height',height * svgScale);
		
		// Create a new SVG with the same dimensions
		const serializer = new XMLSerializer();
		let svgString = serializer.serializeToString(clone);
		
		// Add namespace if not present
		if (!svgString.match(/^<svg[^>]+xmlns="http:\/\/www\.w3\.org\/2000\/svg"/)) {
			svgString = svgString.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
		}

		svgToPng(svgString, width * svgScale, height * svgScale)
		.then((pngUrl) => {
			const pngImg = document.createElement("img");
			pngImg.src = pngUrl;
			document.body.appendChild(pngImg);
			const downloadLink = document.createElement('a');
			downloadLink.href = pngUrl;
			downloadLink.download = 'heatmap_visualization.png';
			downloadLink.click();
			document.body.removeChild(pngImg);
			svgElement.selectAll('.svg-legend-group').remove(); // remove the legend after downloading
			svgElement.select("style").remove();
		})
		.catch((error) => console.error("Error converting SVG to PNG:", error));
	}

	// Show loading indicator
	function showLoading(type, message) {
		d3.select(`#${type}-loading`).text(message || "Loading...");
	}

	// Hide loading indicator
	function hideLoading(type) {
		d3.select(`#${type}-loading`).text('');
	}

	loadCellNames(baseURL + "/data/barley_cellIDs.txt");
	loadGeneNames(baseURL + "/data/barley_geneIDs.txt");

	// Zoom controls
	document.getElementById('zoom-in').addEventListener('click', function() {
		d3.select('#svg-container svg').transition().call(zoom.scaleBy, 1.2);
	});
	
	document.getElementById('zoom-out').addEventListener('click', function() {
		d3.select('#svg-container svg').transition().call(zoom.scaleBy, 0.8);
	});
	
	document.getElementById('reset-zoom').addEventListener('click', resetZoom);
	
	document.getElementById('export-svg').addEventListener('click', exportSVG);
	document.getElementById('export-png').addEventListener('click', exportPNG);
	document.getElementById('download-svg').addEventListener('click', exportSVG);

	// polygon selection with free drawing
	// Freehand drawing variables
	let isSelectionMode = false;
	let isDrawing = false;
	let freehandPath = [];
	let selectionPath = null;
	let selectedPolygonIds = [];
	// let svg = d3.select(container);
	// svg.call(zoom);
	let svg = null;

	// Line generator for the freehand path
	const lineGenerator = d3.line()
		.x(d => d[0])
		.y(d => d[1]);

	// Toggle selection mode
	const toggleButton = d3.select("#toggleSelection");
	const modeInstructions = d3.select("#modeInstructions");
	const downloadExpression = d3.select("#downloadExpression");

	// function to create  n-dimentional arrays
	// createArray(2) - 1 dimention with 2 elements; createArray(3, 2)-3 rows with 2 cols;
	function createArray(length) { 
		let arr = new Array(length || 0),
			i = length;

		if (arguments.length > 1) {
			let args = Array.prototype.slice.call(arguments, 1);
			while(i--) arr[length-1 - i] = createArray.apply(this, args);
		}

		return arr;
	}
	// check whether all values are undefined for an array
	function areAllUndefined(arr) {
		// If the array is empty, it technically contains no elements that are not undefined,
		// so it returns true.
		if (arr.length === 0) {
			return true;
		}
		return arr.every(value => value === undefined);
	}

	downloadExpression.on("click", async function() {
		if (selectedPolygonIds.length > 0) {
			d3.select("#selectedIds").text("Preparing data for downloading... Be patient ...");
			let cmd = "bcftools tabix test2.txt.gz";
			let selectedCellindices = [];
			selectedPolygonIds.forEach(cell => {
				let ind = cellIds.indexOf(cell);
				cmd += " " + (ind + 1);
				selectedCellindices.push(ind);
			});
			console.log(cmd);
			const output = await CLI.exec(cmd);
			// console.log(output);
			let cellData = createArray(geneList.length, selectedPolygonIds.length); // each row is a gene, each col is a cell
			await d3.tsvParse("cellIndex\tgeneIndex\tdata\n" + output, function(d){
				let cellId = cellIds[d.cellIndex - 1]; //Cell-123
				let col = selectedPolygonIds.indexOf(cellId); // col index of cellData
				cellData[d.geneIndex-1][col] = +d.data;
			});
			// convert cellData to csv for downloading
			let csvContent = "data:text/csv;charset=utf-8,";
			csvContent += "Gene," + selectedPolygonIds.join(",") + "\n"; // TrturKRN
			for (let i = 0; i < geneList.length; i++ ) {
				// if(i < 5) console.log(cellData[i]);
				if (!(areAllUndefined(cellData[i]))){
					// const newArray = cellData[i].map(item => (item === undefined ? 0 : item));
					const newArray = Array.from(cellData[i], item => item || 0);
					let row = geneList[i] + "," + newArray.join(",");
					csvContent += row + "\n";
				}
			}

			//calling the csv download via anchor tag(link) so we can provide a name for the file
			let encodedUri = encodeURI(csvContent);
			let link = document.createElement("a");
			link.setAttribute("href", encodedUri);
			link.style.display = 'none';
			link.setAttribute("download", "selected-cell-transcripts.csv"); //change it to give your own name
			link.innerHTML = "Click Here to download";
			document.body.appendChild(link); // Required for FF
			link.click();
			link.remove(); //removing the link after the download

		} else {alert("No cells are selected!");}
	});
	
	toggleButton.on("click", function() {
		// svg = svgElement.selectAll('svg');
		isSelectionMode = !isSelectionMode;
		
		if (isSelectionMode) {
			toggleButton.classed("active", true)
				.text("Disable Cell Selection");
			modeInstructions.text("Selection mode: Click and drag to select polygons");
			svg.on(".zoom", null); // Disable zoom during selection
			// Assuming you have an SVG element and a polygon already created
			svg.selectAll("polygon") // Select all polygons
				.on("click", function(d) {
					// 'd' here is the data bound to the clicked polygon
					const polygonId = d3.select(this).attr("id"); // Get the ID
					console.log("Clicked polygon ID:", polygonId);
					if (selectedPolygonIds.indexOf(polygonId) == -1) {
						selectedPolygonIds.push(polygonId);
					// Change the color to blue
						d3.select(this).attr("fill", "blue");
					} else {// remove it from the list
    					selectedPolygonIds = selectedPolygonIds.filter(item => item !== polygonId);
						d3.select(this).attr("fill", "lightgray");
					}
					// Update the display
					if (selectedPolygonIds.length > 0) {
						document.getElementById("selectedIds").style.display = 'block';
						d3.select("#selectedIds").text("Selected Cells: " + selectedPolygonIds.join(", "));
					} else {
						d3.select("#selectedIds").text("No cells selected");
					}
				});
				// Mouse event handlers for selection
			svg.on("mousedown", function(event) {
				if (!isSelectionMode) return;
				
				// Prevent zoom behavior during selection
				event.stopPropagation();
				
				isDrawing = true;
				freehandPath = [];
				
				// Remove previous selection path if exists
				if (selectionPath) selectionPath.remove();
				
				// Create new selection path
				selectionPath = g.append("path")
					.attr("fill", "rgba(255,255,0,0.2)")
					.attr("stroke", "orange")
					.attr("stroke-width", 0.2);
			});

			svg.on("mousemove", function(event) {
				if (!isSelectionMode || !isDrawing) return;
				
				// Prevent zoom behavior during selection
				event.stopPropagation();
				
				const point = d3.pointer(event, g.node());
				freehandPath.push(point);
				
				selectionPath.attr("d", lineGenerator(freehandPath));
			});

			svg.on("mouseup", function(event) {
				if (!isSelectionMode || !isDrawing) return;
				
				// Prevent zoom behavior during selection
				event.stopPropagation();
				
				isDrawing = false;
				
				if (freehandPath.length > 0) {
					// Close the path
					freehandPath.push(freehandPath[0]);
					selectionPath.attr("d", lineGenerator(freehandPath));
					
					// Find selected polygons
					let newSelectedPolygonIds = findSelectedPolygons();
					selectedPolygonIds = selectedPolygonIds.concat(newSelectedPolygonIds);
					// Create a Set from the array to remove duplicates
					const uniqueSet = new Set(selectedPolygonIds);
					// Convert the Set back to an array
					selectedPolygonIds = [...uniqueSet];
					// Update the display
					if (selectedPolygonIds.length > 0) {
						document.getElementById("selectedIds").style.display = 'block';
						d3.select("#selectedIds").text("Selected Cells: " + selectedPolygonIds.join(", "));
					} else {
						d3.select("#selectedIds").text("No cells selected");
					}
				}
			});
		} else {
			toggleButton.classed("active", false)
				.text("Enable Cell Selection");
			modeInstructions.text("Toggle selection mode to select polygons with freehand drawing");
			svg.call(zoom); // Re-enable zoom
			svg.selectAll("polygon") // Select all polygons
				.on("click", null);
			
			// Clean up any ongoing selection
			if (isDrawing) {
				isDrawing = false;
				freehandPath = [];
				if (selectionPath) selectionPath.remove();
			}
		}
	});

	// Clear selection button
	d3.select("#clear").on("click", () => {
		svg.selectAll("polygon").attr("fill", "lightgray");
		if (selectionPath) selectionPath.remove();
		selectedPolygonIds = [];
		d3.select("#selectedIds").text("Selection cleared");
		document.getElementById("selectedIds").style.display = 'none';
	});

	// get final transformed coordinates
	function newxy(x, y, ctm){
		const originalPoint = new DOMPointReadOnly(x, y); // DOMPointReadOnly {x: 10, y: 20, z: 0, w: 1}
		const newpoint = originalPoint.matrixTransform(ctm); // DOMPoint {x: 25, y: 50, z: 0, w: 1}
		return({x: parseFloat(newpoint.x), y: parseFloat(newpoint.y)});
	}

	// Find polygons that intersect with the selection
	function findSelectedPolygons() {
		const selectionPolygon = freehandPath.map(p => ({x: p[0], y: p[1]}));
		const allPolygons = svg.selectAll("polygon").nodes();
		const selectedIds = [];
		
		allPolygons.forEach(polyElement => {
			const ctm = polyElement.getCTM(); // transformation matrix
			const polyPoints = polyElement.getAttribute("points").split(" ")
				.map(p => p.split(","))
				// .map(p => ({x: parseFloat(p[0]), y: parseFloat(p[1])}));
				.map(p => (newxy(p[0], p[1], ctm)));
			
			if (polygonsIntersect(selectionPolygon, polyPoints)) {
				selectedIds.push(polyElement.id);
				d3.select(polyElement).attr("fill", "red");
			}
		});
		
		return selectedIds;
	}

	// Check if two polygons intersect
	function polygonsIntersect(polyA, polyB) {
		// Check if any point of polyB is inside polyA
		return polyB.some(point => pointInPolygon(point, polyA));
	}

	// Point-in-polygon algorithm
	function pointInPolygon(point, polygon) {
		let inside = false;
		for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
			const xi = polygon[i].x, yi = polygon[i].y;
			const xj = polygon[j].x, yj = polygon[j].y;
			
			const intersect = ((yi > point.y) !== (yj > point.y))
				&& (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
			if (intersect) inside = !inside;
		}
		return inside;
	}

	///////////////////////////////////////////////////
	// view a subset of genes
	// mutliple genes
	const textInput = document.getElementById('textInput');
	const lastBtn = document.getElementById('lastBtn');
	const nextBtn = document.getElementById('nextBtn');
	// const lineOutput = document.getElementById('lineOutput');
	const currentLineSpan = document.getElementById('currentLine');
	const totalLinesSpan = document.getElementById('totalLines');
	
	let lines = [];
	let currentIndex = 0;
	textInput.addEventListener('input', updateLines);
	
	async function updateLines() {
		lines = textInput.value.split('\n').filter(line => line.trim() !== ''); // gene list
		totalLinesSpan.textContent = lines.length;
		
		if (lines.length > 0) {
			currentIndex = 0;
			await updateDisplay();
			nextBtn.disabled = lines.length <= 1;
			lastBtn.disabled = true;
		} else {
			// lineOutput.textContent = "No lines available";
			currentLineSpan.textContent = "0";
			nextBtn.disabled = true;
			lastBtn.disabled = true;
		}
	}
	
	async function updateDisplay() {
		if (lines.length > 0 && currentIndex >= 0 && currentIndex < lines.length) {
			let gene = lines[currentIndex];
			currentLineSpan.textContent = currentIndex + 1;
			// document.getElementById('fill-gene-select').value = gene;// not working for selectize
			let $select1 = $("#fill-gene-select").selectize();
			let selectizeFill = $select1[0].selectize;
			selectizeFill.setValue(gene);
			lastBtn.disabled = currentIndex === 0;
			nextBtn.disabled = currentIndex === lines.length - 1;
		}
	}
	
	lastBtn.addEventListener('click', async () => {
		if (currentIndex > 0) {
			currentIndex--;
			await updateDisplay();
		}
	});
	
	nextBtn.addEventListener('click', async () => {
		if (currentIndex < lines.length - 1) {
			currentIndex++;
			await updateDisplay();
		}
	});

	// Initialize color scales with default domains
	fillColorScale.domain([0, 1]);
	strokeColorScale.domain([0, 1]);

	/////////////////////////////// cell clusters ////////////////////////////
	// Color palette for groups
	const colorPalette = [
		"#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#bcbd22", "#17becf", "#7fc97f",
		"#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#1b9e77", "#d95f02", "#7570b3", "#e7298a",
		"#66a61e", "#e6ab02", "#a6761d", "#4269d0", "#efb118", "#ff725c", "#6cc5b0", "#3ca951", "#ff8ab7", "#a463f2",
		"#97bbf5", "#9c6b4e", "#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00",
		"#cab2d6", "#6a3d9a", "#ffff99", "#b15928", "#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462",
		"#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f", "#4e79a7", "#f28e2c", "#e15759", "#76b7b2",
		"#59a14f", "#edc949", "#af7aa1", "#ff9da7", "#9c755f",
	 ]
	
	// Store group data and colors
	let groupData = {};
	let groupColors = {};
	let groupVisibility = {};
	const DEFAULT_COLOR = '#cccccc'; // Light gray for unselected groups
	await processGroup();

	// function to show all cluster colors
	function showAllClusters(toshow){
		if (toshow) {
			Object.keys(groupVisibility).forEach(groupNum => {
				groupVisibility[groupNum] = true;
				updateGroupColors(groupNum, true);
			});
			d3.selectAll('input[type="checkbox"]:not(#colorblind)').property('checked', true);
			// d3.selectAll('input[type="checkbox"].cluster-checkbox').property('checked', true);
		} else { // uncheck all
				Object.keys(groupVisibility).forEach(groupNum => {
					groupVisibility[groupNum] = false;
					updateGroupColors(groupNum, false);
				});
				d3.selectAll('input[type="checkbox"]:not(#colorblind)').property('checked', false);
		}
	}

	// Create legend from group data
	function createLegend() {
		const legend = d3.select('#legend');
		legend.html('');
		// add a check box to show or hide all clusters
		const legendItem = legend.append('div')
			.attr('class', 'cluster-legend-item');
		// Add checkbox
		const checkboxContainer = legendItem.append('div')
			.attr('class', 'checkbox-container');
		checkboxContainer.append('input')
			.attr('type', 'checkbox')
			.attr('id', `checkall`)
			.attr('class', 'cluster-checkbox')
			.property('checked', false)
			.on('change', function() {
				showAllClusters(this.checked);
			});
		// Add color box and label
		const label = legendItem.append('div')
			.attr('class', 'legend-label')
			.on('click', () => {
					const checkbox = d3.select(`#checkall`).node();
					checkbox.checked = !checkbox.checked;
					showAllClusters(checkbox.checked);
			});
		label.append('span')
			.text(`Show all clusters`);

		const groupNumbers = Object.keys(groupData).sort((a, b) => Number(a) - Number(b));
		// console.log(groupNumbers);
		groupNumbers.forEach((groupNum) => {
			const color = groupColors[groupNum];
			const isVisible = groupVisibility[groupNum];
			const legendItem = legend.append('div')
				.attr('class', 'cluster-legend-item');
			// Add checkbox
			const checkboxContainer = legendItem.append('div')
				.attr('class', 'checkbox-container');
			checkboxContainer.append('input')
				.attr('type', 'checkbox')
				.attr('id', `group-${groupNum}-checkbox`)
				.property('checked', isVisible)
				.on('change', function() {
					const isChecked = this.checked;
					groupVisibility[groupNum] = isChecked;
					updateGroupColors(groupNum, isChecked);
				});
			
			// Add color box and label
			const label = legendItem.append('div')
				.attr('class', 'legend-label')
				.on('click', () => {
					const checkbox = d3.select(`#group-${groupNum}-checkbox`).node();
					checkbox.checked = !checkbox.checked;
					groupVisibility[groupNum] = checkbox.checked;
					updateGroupColors(groupNum, checkbox.checked);
				});
			label.append('input')
			.attr('type', 'color')
			.attr('id', `color${groupNum}`)
			.attr('value', color)
			.style('border', 'none')
			.style('width', '40px')
			.on('click', (event) => event.stopPropagation()) // prevent the parent onclick event
			.on('change', () => {
				const newColor = document.getElementById(`color${groupNum}`).value;
				groupColors[groupNum] = newColor;
				console.log("change color to: ", newColor);
				const checkbox = d3.select(`#group-${groupNum}-checkbox`).node();
				updateGroupColors(groupNum, checkbox.checked);
			});
			let groupName = clusterNames[groupNum];
			label.append('span')
				.text(`${groupNum}: ${groupName}`);
		});
	}

	// Update group colors based on selection state
	function updateGroupColors(groupNum, isSelected) {
		if (!groupData[groupNum]) return;
		const color = isSelected ? groupColors[groupNum] : DEFAULT_COLOR;
		groupData[groupNum].forEach(polyId => {
			let cell = d3.select(`#${polyId}`);
			if(cell.size() > 0) {
				cell.attr('fill', color);
			} 
			// d3.select(`#${polyId}`).attr('fill', color);
		});
	}

	// Process CSV data
	async function processGroup() {
		groupData = {};
		groupVisibility = {};
		groupColors = {};
		Object.keys(clusters).forEach(polyId => {
			const groupNum = clusters[polyId];
			if (!groupData[groupNum]) {
				groupData[groupNum] = [];
				groupVisibility[groupNum] = false; // Default to not selected
				// Assign a color to this group
				groupColors[groupNum] = colorPalette[Object.keys(groupData).length % colorPalette.length];
			}
			groupData[groupNum].push(polyId);

		});
		createLegend();
	}
</script>

</body>
</html>